>  ### [前端基础-JavaScript面试题汇总](https://www.jianshu.com/p/7e71c123b2eb)
 
## 基本数据类型
[01_数据类型.html](./01_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html)
简单数据类型：
+ number
+ string
    - 模板字面量
    ```js
    // 字符串插值, ${}
    let b = 'hahah';
    let a = `<div>${b}1234</div>`
    ```
+ boolean
+ null
+ undefined
+ symbol: 唯一、不可变的; symbol函数不可以和new关键字一起作为构造函数使用。
复杂数据类型
+ object
    - contructor: 用于创建当前对象的函数。
    - hasOwnProperty(propertyName): 用于判断当前对象实例(不是原型)上是否存在给定的属性。要检查的
        属性名必须是字符串(如: o.hasOwnProperty("name"))或符号。
    - isPropertyOf(object): 用于判断当前对象是否为另一个对象的原型。
    - propertyIsEnumerable(propertyName): 用于判断给定的属性是否可以使用for-in语句枚举。

## 基本数据类型和引用数据类型的区别
[JavaScript中基本数据类型和引用数据类型的区别](https://www.cnblogs.com/cxying93/p/6106469.html)

## 堆内存和栈内存的区别
1. 栈内存存储简单数据类型，堆内存存储复杂数据类型
2. 栈内存空间小，读写速度快

## 基本数据类型
+ 原始类型
    - 数值
    - 字符串
    - 布尔
    - symbol(符号)
    - null
    - undefined
+ 对象类型
## 创建对象的几种方式
[创建对象的几种方式](./02_%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html)
1. 工厂模式
```js
function createPerson(name, age, job) {
    let o = new Object()
    o.name = name,
    o.age = age,
    o.job = job,
    o.sayName = function() {
        console.log(this.name)
    }
}
let person3 = createPerson('jeck', 28, '主管')
```
2. 构造函数模式
```js
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
        console.log(this.name)
    }
}
let person2 = new Person('anni', 20, '老师')
```
3. 原型模式
    ```js
    function Person() {}
    Person.prototype.name = 'nike';
    Person.prototype.age = '19';
    Person.prototype.job = '工程师';
    Person.prototype.sayName = function() {console.log(this.name)}
    let person1 = new Person() {}
    ```  
    - 原型：是原型对象的简称，当创建一个函数A的时候，js会按照特定的规则为这个函数创建一个属性，这个属性就是原型对象(prototype),
            原型对象上默认会有一个属性constructor指向这个函数A,通过在原型对象上添加方法，所有实例都会使用这个方法。
    - hasOwnProperty("xxx"): 用来检查实例上是否有xxx属性。
    - 当使用以下格式重写prototype对象的值时，如需要constructor还指向构造函数，则需重写时加上construtor属性；
      ```js
      function Person() {}
      Person.prototype = {
          constructor: Person, // 这时的constructor属性的[[Enumerable]]为true
          name: 'nick',
          ...
      }
      ```
    - 重写构造函数上的原型之后再创建的实例才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。
      ```js
        function Person() {}
        let person1 = new Person();
        Person.prototype = {
            name: 'nike'
        }

        let person2 = new Person();

        console.log(person1.name)  // undefined
        console.log(person2.name) // nike
      ```
    - 原型的问题：
        1. 弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值；
        2. **真正的问题来自包含引用值的属性：因为原型的共享特性，当实例修改原型上的引用属性时，
        会导致其他实例上的该引用属性同时变化，这是因为引用属性都指向同一个地址。

## 变量
+ let
+ const
+ var

## 深浅拷贝
[浅拷贝和深拷贝](https://www.jianshu.com/p/3778af0dbb88)
### 理解：
浅拷贝：仅仅是复制了引用(地址)，相互之间会影响。
深拷贝：在堆中重新分配了内存空间，不同地址，相同的值，不会互相影响。
### 浅拷贝的方法：
1. Object.values()
```js
Object.values({name: 'jamie', age: 18}), // ['jamie', 18]
```
2. Object.entries()
```js
Object.entries({name: 'jamie', age: 18}), // [['name', 'jamie'], ['age', '18']]
```

### 深拷贝的方法：
1. 
2. 

## 作用域链

## 闭包

## this指向

## call,applay,bind
### 共同点：
改变this指向，第一个参数是谁，this就指向谁
### 不同点：
+ call：返回函数调用的返回值；第二个参数和第N个参数逗号分隔
+ applay：返回函数调用的返回值；第二个参数是一个数组
+ bind：返回一个函数的定义；第二个参数和第N个参数逗号分隔; bind只生效一次
```js
var name = '小王', age=17;
var obj = {
    name: '小张',
    objAge: this.age,
    myFun: function(fm, t) {
        console.log(this.name + ' 年龄 ' + this.age,' 来自 ' + fm + '去往' + t);
    }

var db = {
    name: '德玛',
    age: 99

obj.myFun.call(db,'成都','上海');　　　　 // 德玛 年龄 99  来自 成都去往上海
obj.myFun.apply(db,['成都','上海']);      // 德玛 年龄 99  来自 成都去往上海  
obj.myFun.bind(db,'成都','上海')();       // 德玛 年龄 99  来自 成都去往上海
obj.myFun.bind(db,['成都','上海'])();　　 // 德玛 年龄 99  来自 成都, 上海去往 undefined
obj.myFun.bind(this, '佳木斯','南京')();  // 小王 年龄 17  来自 佳木斯去往南京
```

### **bind:**
```js
function f(){
  return this.a;
}

var g = f.bind({a:"azerty"});
console.log(g()); // azerty

var h = g.bind({a:'yoo'}); // bind只生效一次！
console.log(h()); // azerty

var o = {a:37, f:f, g:g, h:h};
console.log(o.a, o.f(), o.g(), o.h()); // 37, 37, azerty, azerty
```

**总结**：call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调用就什么时候调用，并且可以将参数在执行的时候添加，这就是它们的区别。

## 原型链

## 继承

## new做了什么
1. 在内存中创建了一个新对象
2. 这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性
3. 构造函数内部的this指向这个新对象。
4. 新对象拥有构造函数内部的属性
5. 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。

## js如何实现一个类

## 事件队列

## 宏任务与微任务

## js事件传播机制

## 事件代理

## 阻止事件冒泡

## 